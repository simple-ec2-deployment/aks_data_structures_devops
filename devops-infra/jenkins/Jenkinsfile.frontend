// Frontend Build and Deploy Pipeline
// Handles building, testing, and deploying the frontend service

pipeline {
    agent any
    
    options {
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
    }
    
    parameters {
        string(
            name: 'BRANCH_NAME',
            defaultValue: 'main',
            description: 'Git branch to build'
        )
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'prod'],
            description: 'Target environment'
        )
        booleanParam(
            name: 'BUILD_ONLY',
            defaultValue: false,
            description: 'Only build, do not deploy'
        )
        booleanParam(
            name: 'DEPLOY_ONLY',
            defaultValue: false,
            description: 'Only deploy, do not build (uses existing image)'
        )
        string(
            name: 'IMAGE_TAG',
            defaultValue: '',
            description: 'Custom image tag (leave empty for auto-generated)'
        )
    }
    
    environment {
        SERVICE_NAME = 'frontend'
        DOCKER_IMAGE = "ui-service"
        DOCKERFILE_PATH = 'frontend-code'
        K8S_MANIFESTS = 'devops-infra/kubernetes/frontend'
    }
    
    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "==========================================="
                    echo "Frontend Pipeline - ${params.ENVIRONMENT}"
                    echo "Branch: ${params.BRANCH_NAME}"
                    echo "==========================================="
                    
                    // Checkout DevOps repo (current one)
                    checkout scm
                    
                    // Get GitHub organization/user from current repo URL
                    def currentUrl = env.GIT_URL ?: scm.userRemoteConfigs[0].url
                    def githubBase = currentUrl.replaceAll(/https?:\/\/([^\/]+)\/.*/, '$1')
                    def orgOrUser = currentUrl.replaceAll(/https?:\/\/[^\/]+\/([^\/]+)\/.*/, '$1')
                    
                    // Construct Frontend Repo URL
                    def frontendUrl = "https://${githubBase}/${orgOrUser}/aks_data_structures_frontend.git"
                    echo "Frontend Repo URL: ${frontendUrl}"
                    
                    // Checkout Frontend code using PAT token
                    dir('frontend-code') {
                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: "*/${params.BRANCH_NAME}"]],
                            extensions: [[$class: 'CleanBeforeCheckout']],
                            userRemoteConfigs: [[
                                credentialsId: 'github-pat-token',
                                url: frontendUrl
                            ]]
                        ])
                    }
                }
            }
        }
        
        stage('Lint & Test') {
            when {
                expression { return !params.DEPLOY_ONLY }
            }
            steps {
                script {
                    echo "Running linting and tests..."
                }
                
                dir("${DOCKERFILE_PATH}") {
                    sh '''
                        # Add frontend linting/testing commands here
                        echo "Running frontend linting..."
                        # npm run lint || true
                        
                        echo "Running frontend tests..."
                        # npm test || true
                        
                        echo "✓ Lint and tests complete"
                    '''
                }
            }
        }
        
        stage('Build Docker Image') {
            when {
                expression { return !params.DEPLOY_ONLY }
            }
            steps {
                script {
                    // Get git commit SHA for tagging
                    dir("${DOCKERFILE_PATH}") {
                        env.GIT_COMMIT_SHA = sh(
                            script: 'git rev-parse --short HEAD',
                            returnStdout: true
                        ).trim()
                    }
                    
                    def imageTag = params.IMAGE_TAG ?: "${env.BUILD_NUMBER}-${env.GIT_COMMIT_SHA}"
                    env.FINAL_IMAGE_TAG = imageTag
                    
                    echo "Building Docker image: ${DOCKER_IMAGE}:${imageTag}"
                }
                
                dir("${DOCKERFILE_PATH}") {
                    sh '''
                        # Point to Minikube Docker daemon (for local dev)
                        eval $(minikube docker-env) 2>/dev/null || true
                        
                        docker build -t ${DOCKER_IMAGE}:${FINAL_IMAGE_TAG} .
                        docker tag ${DOCKER_IMAGE}:${FINAL_IMAGE_TAG} ${DOCKER_IMAGE}:latest
                        
                        echo "✓ Docker image built successfully"
                        docker images | grep ${DOCKER_IMAGE}
                    '''
                }
            }
        }
        
        stage('Scan Image') {
            when {
                allOf {
                    expression { return !params.DEPLOY_ONLY }
                    expression { return params.ENVIRONMENT == 'prod' }
                }
            }
            steps {
                script {
                    echo "Scanning Docker image for vulnerabilities..."
                }
                
                sh '''
                    # Install Trivy if not available
                    if ! command -v trivy &> /dev/null; then
                        echo "Installing Trivy..."
                        # Add Trivy installation commands here
                    fi
                    
                    # Scan image with Trivy (bonus challenge)
                    # trivy image ${DOCKER_IMAGE}:${FINAL_IMAGE_TAG} || true
                    echo "Image scanning would happen here (Trivy)"
                    echo "✓ Image scan complete"
                '''
            }
        }
        
        stage('Tag Image') {
            when {
                expression { return !params.DEPLOY_ONLY }
            }
            steps {
                script {
                    echo "Tagging Docker image..."
                }
                
                sh '''
                    # Tag with build number
                    docker tag ${DOCKER_IMAGE}:${FINAL_IMAGE_TAG} ${DOCKER_IMAGE}:build-${env.BUILD_NUMBER}
                    
                    # Tag with git SHA
                    docker tag ${DOCKER_IMAGE}:${FINAL_IMAGE_TAG} ${DOCKER_IMAGE}:${env.GIT_COMMIT_SHA}
                    
                    echo "✓ Image tagged successfully"
                '''
            }
        }
        
        stage('Push to Registry') {
            when {
                allOf {
                    expression { return !params.DEPLOY_ONLY }
                    expression { return params.ENVIRONMENT == 'prod' }
                }
            }
            steps {
                script {
                    echo "Pushing image to registry..."
                }
                
                sh '''
                    # Login to registry
                    echo "${DOCKER_CREDENTIALS}" | docker login -u ${DOCKER_REGISTRY_USER} --password-stdin ${DOCKER_REGISTRY} || true
                    
                    # Push all tags
                    docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${FINAL_IMAGE_TAG} || echo "Registry push skipped (using local registry)"
                    docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:build-${env.BUILD_NUMBER} || echo "Registry push skipped"
                    docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${env.GIT_COMMIT_SHA} || echo "Registry push skipped"
                    
                    echo "✓ Images pushed to registry"
                '''
            }
        }
        
        stage('Deploy to Kubernetes') {
            when {
                expression { return !params.BUILD_ONLY }
            }
            steps {
                script {
                    echo "Deploying to ${params.ENVIRONMENT}..."
                }
                
                sh '''
                    # Update image tag in deployment if using Helm
                    if [ -f "${WORKSPACE}/devops-infra/helm/frontend/values.yaml" ]; then
                        # Use Helm for deployment
                        helm upgrade --install frontend ${WORKSPACE}/devops-infra/helm/frontend \
                            --set image.tag=${FINAL_IMAGE_TAG} \
                            --set image.repository=${DOCKER_IMAGE} \
                            --namespace default \
                            --create-namespace || true
                    else
                        # Apply Kubernetes manifests directly
                        kubectl apply -f ${K8S_MANIFESTS}/configmap.yaml
                        
                        # Update image in deployment
                        kubectl set image deployment/frontend-deployment frontend=${DOCKER_IMAGE}:${FINAL_IMAGE_TAG} || \
                        kubectl apply -f ${K8S_MANIFESTS}/deployment.yaml
                        
                        kubectl apply -f ${K8S_MANIFESTS}/service.yaml
                        kubectl apply -f ${K8S_MANIFESTS}/hpa.yaml
                    fi
                    
                    # Wait for rollout
                    kubectl rollout status deployment/frontend-deployment --timeout=300s
                    
                    echo "✓ Frontend deployed successfully"
                '''
            }
        }
        
        stage('Health Check') {
            when {
                expression { return !params.BUILD_ONLY }
            }
            steps {
                script {
                    echo "Running health check..."
                }
                
                sh '''
                    # Wait for pods to be ready
                    kubectl wait --for=condition=ready pod -l app=frontend --timeout=120s
                    
                    # Get pod status
                    echo ""
                    echo "=== Frontend Pods ==="
                    kubectl get pods -l app=frontend -o wide
                    
                    # Port-forward and test
                    kubectl port-forward svc/frontend-service 8080:80 &
                    PF_PID=$!
                    sleep 5
                    
                    # Test frontend health endpoint
                    echo "Testing frontend health endpoint..."
                    curl -f http://localhost:8080/health || echo "Health check endpoint not available"
                    
                    # Test main page
                    echo "Testing main page..."
                    curl -s http://localhost:8080/ | head -20 || echo "Main page not available"
                    
                    # Cleanup
                    kill $PF_PID 2>/dev/null || true
                    
                    echo "✓ Health check passed"
                '''
            }
        }
    }
    
    post {
        success {
            echo """
            ==========================================
            ✓ Frontend Pipeline completed successfully!
            ==========================================
            Service: ${SERVICE_NAME}
            Environment: ${params.ENVIRONMENT}
            Image: ${DOCKER_IMAGE}:${env.FINAL_IMAGE_TAG ?: 'latest'}
            """
        }
        failure {
            echo "✗ Frontend Pipeline failed!"
        }
        always {
            cleanWs()
        }
    }
}
