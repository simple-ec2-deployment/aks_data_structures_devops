// Frontend Build and Deploy Pipeline
// Handles building, testing, and deploying the frontend service
// Runs directly on EC2 where Jenkins is installed

pipeline {
    agent any
    
    options {
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
    }
    
    parameters {
        string(
            name: 'BRANCH_NAME',
            defaultValue: 'main',
            description: 'Git branch to build'
        )
        string(
            name: 'FRONTEND_REPO_URL',
            defaultValue: 'github.com/simple-ec2-deployment/aks_data_structures_frontend.git',
            description: 'Frontend UI repo URL'
        )
        string(
            name: 'MINIKUBE_PROFILE',
            defaultValue: 'minikube',
            description: 'Minikube profile name'
        )
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'prod'],
            description: 'Target environment'
        )
        booleanParam(
            name: 'BUILD_ONLY',
            defaultValue: false,
            description: 'Only build, do not deploy'
        )
        booleanParam(
            name: 'DEPLOY_ONLY',
            defaultValue: false,
            description: 'Only deploy, do not build (uses existing image)'
        )
        string(
            name: 'IMAGE_TAG',
            defaultValue: '',
            description: 'Custom image tag (leave empty for auto-generated)'
        )
    }
    
    environment {
        SERVICE_NAME = 'frontend'
        DOCKER_IMAGE = "ui-service"
        FRONTEND_DIR = '/home/ubuntu/frontend'
        K8S_MANIFESTS = 'devops-infra/kubernetes/frontend'
        EC2_USER = 'ubuntu'
        MINIKUBE_PROFILE = "${params.MINIKUBE_PROFILE}"
        GITHUB_PAT = credentials('github-pat-token')
    }
    
    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "==========================================="
                    echo "Frontend Pipeline - ${params.ENVIRONMENT}"
                    echo "Branch: ${params.BRANCH_NAME}"
                    echo "==========================================="
                }
                
                checkout scm
                
                sh '''
                    sudo -u ${EC2_USER} -H bash -c "
                        set -euo pipefail
                        : \"\${BRANCH:=${BRANCH_NAME}}\"
                        
                        normalize_url() {
                            local input=\"\$1\"
                            if echo \"\$input\" | grep -qiE '^git@github.com:'; then
                                input=\$(echo \"\$input\" | sed -E 's|^git@github.com:|https://github.com/|')
                            elif echo \"\$input\" | grep -qiE '^ssh://git@github.com/'; then
                                input=\$(echo \"\$input\" | sed -E 's|^ssh://git@github.com/|https://github.com/|')
                            elif ! echo \"\$input\" | grep -qiE '^https?://'; then
                                input=\"https://\$input\"
                            fi
                            echo \"\$input\"
                        }
                        
                        if [ -n \"${GITHUB_PAT_PSW:-}\" ]; then
                            TOKEN=\"${GITHUB_PAT_PSW}\"
                        else
                            TOKEN=\"${GITHUB_PAT}\"
                        fi
                        AUTH_B64=\$(printf '%s' \"${GITHUB_PAT_USR:-x-access-token}:\$TOKEN\" | base64 | tr -d '\n')
                        AUTH_HEADER=\"Authorization: Basic \$AUTH_B64\"
                        
                        FULL_URL=\"\$(normalize_url \"${FRONTEND_REPO_URL}\")\"
                        echo \"Cloning frontend repo: \$FULL_URL\"
                        
                        if [ ! -d \"${FRONTEND_DIR}/.git\" ]; then
                            mkdir -p \"${FRONTEND_DIR}\"
                            echo \"Cloning repository from branch: \$BRANCH...\"
                            git -c http.extraHeader=\"\$AUTH_HEADER\" clone -b \"\$BRANCH\" \"\$FULL_URL\" \"${FRONTEND_DIR}\"
                        else
                            echo \"Repository exists, pulling latest changes from branch: \$BRANCH...\"
                            cd \"${FRONTEND_DIR}\"
                            git config --global --add safe.directory \"${FRONTEND_DIR}\"
                            git checkout \"\$BRANCH\" || git checkout -b \"\$BRANCH\" \"origin/\$BRANCH\"
                            git -c http.extraHeader=\"\$AUTH_HEADER\" pull \"\$FULL_URL\" \"\$BRANCH\" || {
                                echo \"Pull failed, trying to reset...\"
                                git fetch --all
                                git reset --hard \"origin/\$BRANCH\"
                            }
                        fi
                        
                        cd \"${FRONTEND_DIR}\"
                        echo \"Current branch: \$(git branch --show-current)\"
                        echo \"Latest commit:  \$(git rev-parse --short HEAD)\"
                    "
                '''
            }
        }
        
        stage('Lint & Test') {
            when {
                expression { return !params.DEPLOY_ONLY }
            }
            steps {
                sh '''
                    sudo -u ${EC2_USER} -H bash -c "
                        set -euo pipefail
                        cd \"${FRONTEND_DIR}\"
                        
                        # Add frontend linting/testing commands here
                        echo \"Running frontend linting...\"
                        # npm run lint || true
                        
                        echo \"Running frontend tests...\"
                        # npm test || true
                        
                        echo \"✓ Lint and tests complete\"
                    "
                '''
            }
        }
        
        stage('Build Docker Image') {
            when {
                expression { return !params.DEPLOY_ONLY }
            }
            steps {
                sh '''
                    sudo -u ${EC2_USER} -H bash -c "
                        set -euo pipefail
                        
                        cd \"${FRONTEND_DIR}\"
                        
                        # Get git commit SHA for tagging
                        GIT_COMMIT_SHA=\$(git rev-parse --short HEAD)
                        
                        # Point Docker to Minikube daemon
                        eval \"\$(minikube -p ${MINIKUBE_PROFILE} docker-env)\"
                        
                        # Build image
                        IMAGE_TAG=\"${IMAGE_TAG:-build-${BUILD_NUMBER}-\$GIT_COMMIT_SHA}\"
                        echo \"Building Docker image: ${DOCKER_IMAGE}:\$IMAGE_TAG\"
                        
                        docker build -t ${DOCKER_IMAGE}:\$IMAGE_TAG .
                        docker tag ${DOCKER_IMAGE}:\$IMAGE_TAG ${DOCKER_IMAGE}:latest
                        docker tag ${DOCKER_IMAGE}:\$IMAGE_TAG ${DOCKER_IMAGE}:build-${BUILD_NUMBER}
                        docker tag ${DOCKER_IMAGE}:\$IMAGE_TAG ${DOCKER_IMAGE}:\$GIT_COMMIT_SHA
                        
                        echo \"✓ Docker image built successfully\"
                        docker images | grep ${DOCKER_IMAGE}
                        
                        # Store image tag for deployment
                        echo \"\$IMAGE_TAG\" > /tmp/frontend-image-tag.txt
                    "
                '''
            }
        }
        
        stage('Deploy to Kubernetes') {
            when {
                expression { return !params.BUILD_ONLY }
            }
            steps {
                sh '''
                    sudo -u ${EC2_USER} -H bash -c "
                        set -euo pipefail
                        
                        cd \"${WORKSPACE}\"
                        
                        # Get image tag
                        if [ -f /tmp/frontend-image-tag.txt ]; then
                            IMAGE_TAG=\$(cat /tmp/frontend-image-tag.txt)
                        else
                            IMAGE_TAG=\"latest\"
                        fi
                        
                        # Ensure kubectl context is set
                        kubectl config use-context ${MINIKUBE_PROFILE} || true
                        
                        # Apply Kubernetes manifests
                        kubectl apply -f ${K8S_MANIFESTS}/configmap.yaml || true
                        
                        # Update image in deployment
                        kubectl set image deployment/frontend-deployment frontend=${DOCKER_IMAGE}:\$IMAGE_TAG || \
                        kubectl apply -f ${K8S_MANIFESTS}/deployment.yaml
                        
                        kubectl apply -f ${K8S_MANIFESTS}/service.yaml || true
                        kubectl apply -f ${K8S_MANIFESTS}/hpa.yaml || true
                        
                        # Wait for rollout
                        kubectl rollout status deployment/frontend-deployment --timeout=300s || true
                        
                        echo \"✓ Frontend deployed successfully\"
                    "
                '''
            }
        }
        
        stage('Health Check') {
            when {
                expression { return !params.BUILD_ONLY }
            }
            steps {
                sh '''
                    sudo -u ${EC2_USER} -H bash -c "
                        set -euo pipefail
                        
                        # Wait for pods to be ready
                        kubectl wait --for=condition=ready pod -l app=frontend --timeout=120s || true
                        
                        # Get pod status
                        echo \"\"
                        echo \"=== Frontend Pods ===\"
                        kubectl get pods -l app=frontend -o wide
                        
                        # Port-forward and test
                        kubectl port-forward svc/frontend-service 8080:80 &
                        PF_PID=\$!
                        sleep 5
                        
                        # Test frontend health endpoint
                        echo \"Testing frontend health endpoint...\"
                        curl -f http://localhost:8080/health || echo \"Health check endpoint not available\"
                        
                        # Test main page
                        echo \"Testing main page...\"
                        curl -s http://localhost:8080/ | head -20 || echo \"Main page not available\"
                        
                        # Cleanup
                        kill \$PF_PID 2>/dev/null || true
                        
                        echo \"✓ Health check passed\"
                    "
                '''
            }
        }
    }
    
    post {
        success {
            echo """
            ==========================================
            ✓ Frontend Pipeline completed successfully!
            ==========================================
            Service: ${SERVICE_NAME}
            Environment: ${params.ENVIRONMENT}
            """
        }
        failure {
            echo "✗ Frontend Pipeline failed!"
        }
        always {
            cleanWs()
        }
    }
}
