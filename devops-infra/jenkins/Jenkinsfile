// Main Orchestration Pipeline
// This pipeline orchestrates the deployment of all services
// Runs directly on EC2 where Jenkins is installed

pipeline {
    agent any
    
    options {
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 60, unit: 'MINUTES')
    }
    
    parameters {
        string(
            name: 'BRANCH_NAME',
            defaultValue: 'main',
            description: 'Git branch to deploy'
        )
        string(
            name: 'INFRA_REPO_URL',
            defaultValue: 'github.com/simple-ec2-deployment/aks_data_structures_devops.git',
            description: 'Infrastructure repo URL'
        )
        string(
            name: 'API_REPO_URL',
            defaultValue: 'github.com/simple-ec2-deployment/aks_data_structures_backend.git',
            description: 'Backend API repo URL'
        )
        string(
            name: 'FRONTEND_REPO_URL',
            defaultValue: 'github.com/simple-ec2-deployment/aks_data_structures_frontend.git',
            description: 'Frontend UI repo URL'
        )
        string(
            name: 'MINIKUBE_PROFILE',
            defaultValue: 'minikube',
            description: 'Minikube profile name'
        )
        booleanParam(
            name: 'DEPLOY_MONITORING',
            defaultValue: false,
            description: 'Deploy monitoring stack (Prometheus + Grafana)'
        )
    }
    
    environment {
        BRANCH_NAME = "${params.BRANCH_NAME ?: 'main'}"
        GITHUB_PAT = credentials('github-pat-token')
        MINIKUBE_PROFILE = "${params.MINIKUBE_PROFILE}"
        EC2_USER = 'ubuntu'
        REPO_DIR = '/home/ubuntu/aks_data_structures_devops'
        API_DIR = '/home/ubuntu/backend'
        FRONTEND_DIR = '/home/ubuntu/frontend'
    }
    
    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "=========================================="
                    echo "Stage: Checkout (Branch: ${params.BRANCH_NAME})"
                    echo "=========================================="
                }
                
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${params.BRANCH_NAME}"]],
                    extensions: [[$class: 'CleanBeforeCheckout']],
                    userRemoteConfigs: [[
                        credentialsId: 'github-pat-token',
                        url: "https://${params.INFRA_REPO_URL}"
                    ]]
                ])
            }
        }
        
        stage('Ensure Minikube is Running') {
            steps {
                script {
                    echo "=========================================="
                    echo "Stage: Ensuring Minikube is running"
                    echo "=========================================="
                }
                
                sh '''
                    sudo -u ${EC2_USER} -H bash -c "
                        set -euo pipefail
                        
                        # Fix permissions from earlier sudo/root runs
                        sudo mkdir -p \"/home/${EC2_USER}/.minikube\" \"/home/${EC2_USER}/.kube\"
                        sudo chown -R \"${EC2_USER}:${EC2_USER}\" \"/home/${EC2_USER}/.minikube\" \"/home/${EC2_USER}/.kube\"
                        
                        # Ensure docker is usable
                        if ! id -nG \"${EC2_USER}\" | tr ' ' '\n' | grep -qx docker; then
                            echo 'Adding user to docker group...'
                            sudo usermod -aG docker \"${EC2_USER}\"
                        fi
                        sudo systemctl enable docker >/dev/null 2>&1 || true
                        sudo systemctl restart docker >/dev/null 2>&1 || true
                        sudo chmod 666 /var/run/docker.sock >/dev/null 2>&1 || true
                        
                        echo 'Docker socket check:'
                        docker version || {
                            echo 'Failed to access docker socket even after docker group fixes.'
                            exit 1
                        }
                        
                        # Check if Minikube is running
                        if minikube status -p ${MINIKUBE_PROFILE} 2>/dev/null | grep -q Running; then
                            echo '✓ Minikube is already running'
                        else
                            echo 'Starting Minikube...'
                            minikube start -p ${MINIKUBE_PROFILE} --driver=docker || {
                                echo 'Failed to start Minikube'
                                exit 1
                            }
                            echo '✓ Minikube started successfully'
                        fi
                        
                        # Get Minikube IP
                        MINIKUBE_IP=\$(minikube ip -p ${MINIKUBE_PROFILE} 2>/dev/null || true)
                        if [ -n \"\$MINIKUBE_IP\" ]; then
                            echo \"Minikube IP: \$MINIKUBE_IP\"
                        fi
                        
                        # Verify kubectl access
                        kubectl cluster-info || {
                            echo 'ERROR: Cannot access Kubernetes cluster'
                            exit 1
                        }
                    "
                '''
            }
        }
        
        stage('Clone Service Repos') {
            steps {
                script {
                    echo "=========================================="
                    echo "Stage: Cloning service repositories"
                    echo "=========================================="
                }
                
                sh '''
                    sudo -u ${EC2_USER} -H bash -c "
                        set -euo pipefail
                        : \"\${BRANCH:=${BRANCH_NAME}}\"
                        
                        normalize_url() {
                            local input=\"\$1\"
                            if echo \"\$input\" | grep -qiE '^git@github.com:'; then
                                input=\$(echo \"\$input\" | sed -E 's|^git@github.com:|https://github.com/|')
                            elif echo \"\$input\" | grep -qiE '^ssh://git@github.com/'; then
                                input=\$(echo \"\$input\" | sed -E 's|^ssh://git@github.com/|https://github.com/|')
                            elif ! echo \"\$input\" | grep -qiE '^https?://'; then
                                input=\"https://\$input\"
                            fi
                            echo \"\$input\"
                        }
                        
                        if [ -n \"${GITHUB_PAT_PSW:-}\" ]; then
                            TOKEN=\"${GITHUB_PAT_PSW}\"
                        else
                            TOKEN=\"${GITHUB_PAT}\"
                        fi
                        AUTH_B64=\$(printf '%s' \"${GITHUB_PAT_USR:-x-access-token}:\$TOKEN\" | base64 | tr -d '\n')
                        AUTH_HEADER=\"Authorization: Basic \$AUTH_B64\"
                        
                        clone_or_update() {
                            local url=\"\$1\"; local dir=\"\$2\"
                            local full=\"\$(normalize_url \"\$url\")\"
                            if [ ! -d \"\$dir/.git\" ]; then
                                echo \"Cloning \$full to \$dir (branch: \$BRANCH) ...\"
                                git -c http.extraHeader=\"\$AUTH_HEADER\" clone -b \"\$BRANCH\" \"\$full\" \"\$dir\"
                            else
                                echo \"Updating \$dir (branch: \$BRANCH) ...\"
                                cd \"\$dir\"
                                git config --global --add safe.directory \"\$dir\"
                                git checkout \"\$BRANCH\" || git checkout -b \"\$BRANCH\" \"origin/\$BRANCH\"
                                git -c http.extraHeader=\"\$AUTH_HEADER\" pull \"\$full\" \"\$BRANCH\" || { git fetch --all; git reset --hard \"origin/\$BRANCH\"; }
                            fi
                        }
                        
                        clone_or_update \"${API_REPO_URL}\" \"${API_DIR}\"
                        clone_or_update \"${FRONTEND_REPO_URL}\" \"${FRONTEND_DIR}\"
                        
                        echo ''
                        echo '=== Repo status ==='
                        for repo in \"${API_DIR}\" \"${FRONTEND_DIR}\"; do
                            if [ -d \"\$repo/.git\" ]; then
                                cd \"\$repo\"
                                echo \"[\$repo]\"
                                echo '  Branch:' \$(git branch --show-current)
                                echo '  Commit:' \$(git log -1 --oneline)
                            fi
                        done
                    "
                '''
            }
        }
        
        stage('Build Docker Images') {
            steps {
                script {
                    echo "=========================================="
                    echo "Stage: Building Docker images"
                    echo "=========================================="
                }
                
                sh '''
                    sudo -u ${EC2_USER} -H bash -c "
                        set -euo pipefail
                        
                        cd \"${REPO_DIR}\"
                        
                        # Point Docker to Minikube
                        eval \"\$(minikube -p ${MINIKUBE_PROFILE} docker-env)\"
                        
                        build_if_exists() {
                            local tag=\"\$1\"; local path=\"\$2\"
                            if [ -f \"\$path/Dockerfile\" ]; then
                                echo \"Building \$tag:latest from \$path ...\"
                                docker build -t \"\$tag:latest\" \"\$path\" || { echo \"ERROR: Failed to build \$tag\"; exit 1; }
                                echo \"✓ Successfully built \$tag:latest\"
                            else
                                echo \"WARNING: Dockerfile not found at \$path\"
                            fi
                        }
                        
                        # Data-structures services (from infra repo)
                        build_if_exists stack-service \"${REPO_DIR}/stack\"
                        build_if_exists linkedlist-service \"${REPO_DIR}/linkedlist\"
                        build_if_exists graph-service \"${REPO_DIR}/graph\"
                        
                        # API service
                        build_if_exists backend-service \"${API_DIR}\"
                        
                        # Frontend service
                        build_if_exists ui-service \"${FRONTEND_DIR}\"
                        
                        echo ''
                        echo 'All images built successfully:'
                        docker images | grep -E '(stack-service|linkedlist-service|graph-service|backend-service|ui-service)' || true
                    "
                '''
            }
        }
        
        stage('Deploy to Kubernetes') {
            steps {
                script {
                    echo "=========================================="
                    echo "Stage: Deploying to Kubernetes"
                    echo "=========================================="
                }
                
                sh '''
                    sudo -u ${EC2_USER} -H bash -c "
                        set -euo pipefail
                        
                        cd \"${REPO_DIR}\"
                        
                        # Ensure kubectl context is set to Minikube
                        kubectl config use-context ${MINIKUBE_PROFILE} || {
                            echo 'WARNING: Could not set kubectl context, continuing...'
                        }
                        
                        # Make deployment script executable
                        chmod +x devops-infra/scripts/deploy-ec2.sh
                        
                        # Run deployment script
                        echo 'Running deployment script...'
                        ./devops-infra/scripts/deploy-ec2.sh dev ${DEPLOY_MONITORING} || {
                            echo 'ERROR: Deployment script failed'
                            exit 1
                        }
                        
                        echo '✓ Deployment completed successfully'
                    "
                '''
            }
        }
        
        stage('Verify Deployment') {
            steps {
                script {
                    echo "=========================================="
                    echo "Stage: Verifying deployment"
                    echo "=========================================="
                }
                
                sh '''
                    sudo -u ${EC2_USER} -H bash -c "
                        set -euo pipefail
                        
                        echo 'Waiting for pods to be ready...'
                        MAX_RETRIES=40
                        RETRY_COUNT=0
                        
                        while [ \$RETRY_COUNT -lt \$MAX_RETRIES ]; do
                            PODS=\$(kubectl get pods --no-headers 2>/dev/null)
                            
                            if [ -z \"\$PODS\" ]; then
                                echo 'No pods found yet, waiting...'
                                sleep 5
                                RETRY_COUNT=\$((RETRY_COUNT + 1))
                                continue
                            fi
                            
                            NOT_READY=\$(echo \"\$PODS\" | grep -v 'Running' | grep -v 'Completed' | wc -l | tr -d ' ')
                            
                            if [ \"\$NOT_READY\" -eq 0 ] && [ -n \"\$PODS\" ]; then
                                echo '✓ All pods are Running!'
                                break
                            fi
                            
                            if [ \$((RETRY_COUNT % 5)) -eq 0 ]; then
                                echo \"Still waiting for pods... (attempt \$RETRY_COUNT/\$MAX_RETRIES)\"
                                kubectl get pods || true
                            fi
                            
                            sleep 3
                            RETRY_COUNT=\$((RETRY_COUNT + 1))
                        done
                        
                        if [ \$RETRY_COUNT -ge \$MAX_RETRIES ]; then
                            echo 'WARNING: Timeout waiting for pods. Current status:'
                            kubectl get pods || true
                        fi
                        
                        echo ''
                        echo '=========================================='
                        echo 'Kubernetes Resources Status:'
                        echo '=========================================='
                        
                        echo ''
                        echo '=== Pods ==='
                        kubectl get pods -o wide || true
                        
                        echo ''
                        echo '=== Services ==='
                        kubectl get services || true
                        
                        echo ''
                        echo '=== Deployments ==='
                        kubectl get deployments || true
                        
                        echo ''
                        echo '=== Ingress ==='
                        kubectl get ingress || true
                        
                        # Get access URLs
                        MINIKUBE_IP=\$(minikube ip -p ${MINIKUBE_PROFILE} 2>/dev/null || echo 'unknown')
                        
                        echo ''
                        echo '=========================================='
                        echo 'Access URLs:'
                        echo '=========================================='
                        echo \"Internal (Minikube): http://\$MINIKUBE_IP:32080/\"
                        echo ''
                    "
                '''
            }
        }
    }
    
    post {
        success {
            echo """
            ==========================================
            ✓ Pipeline completed successfully!
            ==========================================
            Branch: ${params.BRANCH_NAME}
            Minikube Profile: ${params.MINIKUBE_PROFILE}
            Monitoring: ${params.DEPLOY_MONITORING}
            """
        }
        always {
            echo """
            ==========================================
            Pipeline execution completed.
            ==========================================
            """
        }
    }
}
